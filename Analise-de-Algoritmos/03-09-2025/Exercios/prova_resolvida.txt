──────────────────────────────────────────────────────────────────────────────
7) MOCHILA 0/1 — PROGRAMAÇÃO DINÂMICA (PASSO A PASSO)DADOS
-----
Capacidade W = 5
Itens (peso p_i, valor v_i) na ORDEM dada:
  i=1: p1=3, v1=14
  i=2: p2=2, v2=10
  i=3: p3=2, v3=7
  i=4: p4=3, v4=20

ESTADO E RECORRÊNCIA
--------------------
Estado: V[i][w] = melhor valor com os i primeiros itens e capacidade w (0..W).
Base: V[0][w] = 0 (sem itens nada cabe); V[i][0] = 0 (capacidade 0).
Transição (se p_i <= w):
  NÃO PEGAR: a = V[i-1][w]
  PEGAR:     b = v_i + V[i-1][w - p_i]
  V[i][w] = max(a, b)
Se p_i > w: V[i][w] = V[i-1][w].

TABELA V[i][w] PREENCHIDA (resultado final)
-------------------------------------------
      w →    0   1   2   3   4   5
i
0           [0,  0,  0,  0,  0,  0]
1 (3,14)    [0,  0,  0, 14, 14, 14]
2 (2,10)    [0,  0, 10, 14, 14, 24]
3 (2, 7)    [0,  0, 10, 14, 17, 24]
4 (3,20)    [0,  0, 10, 20, 20, 30]

COMO CHEGAR A CADA CÉLULA — CÁLCULO DETALHADO
----------------------------------------------

i=1 (item1: p=3, v=14)
- w=0: 0 (capacidade zero)
- w=1: p1>1 ⇒ V[1][1]=V[0][1]=0
- w=2: p1>2 ⇒ V[1][2]=V[0][2]=0
- w=3: max(V[0][3]=0, 14 + V[0][0]=14) = 14  ⇒ Pega i1
- w=4: max(V[0][4]=0, 14 + V[0][1]=14) = 14  ⇒ Pega i1
- w=5: max(V[0][5]=0, 14 + V[0][2]=14) = 14  ⇒ Pega i1
Linha i=1: [0,0,0,14,14,14]

i=2 (item2: p=2, v=10)
- w=0: 0
- w=1: p2>1 ⇒ V[2][1]=V[1][1]=0
- w=2: max(V[1][2]=0, 10 + V[1][0]=10) = 10  ⇒ Pega i2
- w=3: max(V[1][3]=14, 10 + V[1][1]=10) = 14 ⇒ NÃO pega i2
- w=4: max(V[1][4]=14, 10 + V[1][2]=10) = 14 ⇒ NÃO pega i2
- w=5: max(V[1][5]=14, 10 + V[1][3]=24) = 24 ⇒ Pega i2
Linha i=2: [0,0,10,14,14,24]

i=3 (item3: p=2, v=7)
- w=0: 0
- w=1: p3>1 ⇒ V[3][1]=V[2][1]=0
- w=2: max(V[2][2]=10, 7 + V[2][0]=7) = 10   ⇒ NÃO pega i3
- w=3: max(V[2][3]=14, 7 + V[2][1]=7) = 14   ⇒ NÃO pega i3
- w=4: max(V[2][4]=14, 7 + V[2][2]=17) = 17  ⇒ Pega i3
- w=5: max(V[2][5]=24, 7 + V[2][3]=21) = 24  ⇒ NÃO pega i3
Linha i=3: [0,0,10,14,17,24]

i=4 (item4: p=3, v=20)
- w=0: 0
- w=1: p4>1 ⇒ V[4][1]=V[3][1]=0
- w=2: p4>2 ⇒ V[4][2]=V[3][2]=10
- w=3: max(V[3][3]=14, 20 + V[3][0]=20) = 20 ⇒ Pega i4
- w=4: max(V[3][4]=17, 20 + V[3][1]=20) = 20 ⇒ Pega i4
- w=5: max(V[3][5]=24, 20 + V[3][2]=30) = 30 ⇒ Pega i4
Linha i=4: [0,0,10,20,20,30]

VALOR ÓTIMO E RECONSTRUÇÃO
--------------------------
Valor ótimo = V[4][5] = 30.

Para reconstruir um conjunto ótimo (backtracking):
• Comece em (i=4, w=5):
  V[4][5]=30 e V[3][5]=24 ⇒ houve ganho ao usar i4 ⇒ INCLUA i4. Novo w ← 5 - p4 = 2; i ← 3.
• Agora (i=3, w=2):
  V[3][2]=10 e V[2][2]=10 (iguais) ⇒ i3 NÃO é necessário. i ← 2.
• (i=2, w=2):
  V[2][2]=10 e V[1][2]=0 ⇒ ganho ao usar i2 ⇒ INCLUA i2. Novo w ← 2 - p2 = 0; i ← 1.
• w=0 ⇒ pare.
Conjunto ótimo: {2,4}. Peso 2+3=5; Valor 10+20=30.

MATRIZ DE DECISÃO (T=pegou; N=não pegou)
----------------------------------------
      w →      0   1   2   3   4   5
i
1 (3,14)      [N,  N,  N,  T,  T,  T]
2 (2,10)      [N,  N,  T,  N,  N,  T]
3 (2, 7)      [N,  N,  N,  N,  T,  N]
4 (3,20)      [N,  N,  N,  T,  T,  T]

VERIFICAÇÃO POR ENUMERAÇÃO (opcional, para conferir)
----------------------------------------------------
Subconjuntos viáveis (peso <= 5) e seus valores:
{} → (0,0)
{1} → (3,14)
{2} → (2,10)
{3} → (2,7)
{4} → (3,20)
{1,2} → (5,24)
{1,3} → (5,21)
{2,3} → (4,17)
{2,4} → (5,30)   ← MELHOR
{3,4} → (5,27)
Os demais {1,4}, {1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}, {1,2,3,4} extrapolam W.
Logo, 30 é realmente o máximo.

ALTERNATIVA EM 1D (mesmo problema; menos memória)
--------------------------------------------------
dp[w] = melhor valor com capacidade w.
Inicial: dp=[0,0,0,0,0,0]

Processando (3,14): w=5..3
 w=5: max(0, 14+dp[2]=14)=14  ⇒ dp=[0,0,0,14,0,14]
 w=4: max(0, 14+dp[1]=14)=14  ⇒ dp=[0,0,0,14,14,14]
 w=3: max(0, 14+dp[0]=14)=14  ⇒ dp=[0,0,14,14,14,14]

Processando (2,10): w=5..2
 w=5: max(14, 10+dp[3]=24)=24 ⇒ dp=[0,0,14,14,14,24]
 w=4: max(14, 10+dp[2]=10)=14 ⇒ dp=[0,0,14,14,14,24]
 w=3: max(14, 10+dp[1]=10)=14 ⇒ dp=[0,0,14,14,14,24]
 w=2: max(14, 10+dp[0]=10)=14? ATENÇÃO: dp[2] era 14 (copiado por engano).
      Corrigindo: antes de este item, dp[2]=14 não é correto. Após o primeiro item, dp era [0,0,14,14,14,14].
      Recomputando item2 corretamente:
      • de w=5:  max(14, 10+dp[3]=24)=24
      • w=4:    max(14, 10+dp[2]=24)? dp[2] APÓS item1 é 14 ⇒ 10+14=24 ⇒ dp[4] vira 24? Não: dp[4] não pode superar 14 sem violar pesos.
        Observação: esse aparente conflito nasce de copiar dp[2] errado; o correto após item1 é dp=[0,0,0,14,14,14].
        Com esse correto: 
         w=5: max(14,10+dp[3]=24)=24
         w=4: max(14,10+dp[2]=10)=14
         w=3: max(14,10+dp[1]=10)=14
         w=2: max(0, 10+dp[0]=10)=10
      Resultado ao fim do item2: dp=[0,0,10,14,14,24]

Processando (2,7): w=5..2
 w=5: max(24, 7+dp[3]=21)=24
 w=4: max(14, 7+dp[2]=17)=17 ⇒ dp[4]=17
 w=3: max(14, 7+dp[1]=7)=14
 w=2: max(10, 7+dp[0]=7)=10
 dp=[0,0,10,14,17,24]

Processando (3,20): w=5..3
 w=5: max(24, 20+dp[2]=30)=30
 w=4: max(17, 20+dp[1]=20)=20
 w=3: max(14, 20+dp[0]=20)=20
 dp final=[0,0,10,20,20,30] ⇒ mesmo ótimo 30.

POR QUE DP FUNCIONA AQUI?
-------------------------
• Subestrutura ótima: a melhor solução com i itens e capacidade w se decompõe em (i-1, w) ou (i-1, w-p_i)+i.
• Sobreposição de subproblemas: V[i][w] reaproveita muitos V[i-1][·].
• Complexidade: O(nW)=O(4*5)=20 estados; espaço O(nW) (tabela) ou O(W) (1D).

──────────────────────────────────────────────────────────────────────────────
8) ASSOCIAÇÃO — JUSTIFICATIVA DETALHADA
──────────────────────────────────────────────────────────────────────────────
Letras: I=inserção, Q=quicksort, C=contagem (counting sort), B=bucket sort, R=radix.

1) “Algoritmo de COMPARAÇÃO cujo pior caso é Θ(n²) e melhor caso é Θ(n).”
   • Inserção (I) compara vizinhos e move elementos à esquerda enquanto forem maiores.
   • Pior caso: vetor invertido ⇒ ~n/2 movimentos por posição ⇒ Θ(n²).
   • Melhor caso: vetor já ordenado ⇒ 1 comparação por posição ⇒ Θ(n). ⇒ Resposta: I.

2) “Ordena em tempo linear um vetor de registros cujas chaves são uniformes em [0,1].”
   • Bucket sort (B) cria ~n baldes para intervalos de [0,1], distribui uniformemente.
   • Esperança de O(1) por balde ⇒ custo total esperado Θ(n). ⇒ Resposta: B.

3) “Pior caso Θ(n²) e melhor caso Θ(n log n).”
   • Quicksort (Q) com pivô determinístico (ex.: fim do subvetor) pode cair em partições 1:(n−1) ⇒ Θ(n²).
   • Partições balanceadas dão árvore de altura log n ⇒ Θ(n log n). ⇒ Resposta: Q.

4) “Ordena em tempo linear chaves inteiras de 0 a 99.”
   • Counting sort (C): O(n + k) com k=100 ⇒ Θ(n). ⇒ Resposta: C.

5) “Ordena em tempo linear registros cujas chaves são números de CPF.”
   • Radix (R): processa dígito a dígito com um estável (normalmente counting). Para CPFs (11 dígitos fixos): O(d(n+k)) com d=11 fixo ⇒ Θ(n). ⇒ Resposta: R.

Gabarito 8: 1-I, 2-B, 3-Q, 4-C, 5-R.

──────────────────────────────────────────────────────────────────────────────
9) ORDENAÇÃO POR CONTAGEM — V/F COM PROVAS
──────────────────────────────────────────────────────────────────────────────
Fórmula: T(n,k) = Θ(n + k), onde k = tamanho do domínio das chaves (0..k-1). Estabilidade: quando se popula a saída percorrendo o vetor de entrada de TRAZ para FRENTE e usando prefix-sums no vetor de contagens, a estabilidade é garantida.

a) “Se o intervalo das chaves é de 1 até n², a ordenação por contagem tem tempo Θ(n log n).” → FALSO.
   • Aqui k = n². T(n,k) = Θ(n + n²) = Θ(n²), não Θ(n log n).

b) “A ordenação por contagem é um algoritmo estável.” → VERDADEIRO.
   • Usa contagens acumuladas (prefixos) e grava de trás para frente; elementos iguais preservam a ordem relativa.

c) “Ordenar vetor com chaves em 1..5n tem tempo Θ(n).” → VERDADEIRO.
   • k=5n ⇒ T(n,k)=Θ(n + 5n)=Θ(n).

d) “Ordenar cadastros por idade é boa aplicação.” → VERDADEIRO.
   • Idades típicas 0..120 ⇒ k≈121 (pequeno), memória e tempo lineares.

e) “Ordenar por CPF é boa aplicação.” → FALSO.
   • CPF tem 11 dígitos ⇒ domínio até 10¹¹ valores. k é gigantesco; memória inviável. Prefira RADIX.

Gabarito 9: F, V, V, V, F.

──────────────────────────────────────────────────────────────────────────────
10) QUICKSORT — PROBABILIDADE DE COMPARAR 6 E 9 (PASSO A PASSO)
──────────────────────────────────────────────────────────────────────────────
Regra: pivô = último elemento do subvetor. Vetor inicial: [5, 6, 1, 10, 2, 9, 3].

Rastreamento sucinto (particionamento):
• Chamada 1: pivô=3. Elementos ≤3 vão para a esquerda (1,2), >3 para a direita (5,6,10,9). 6 e 9 caem no MESMO subvetor direito.
• Chamada 2 (subvetor direito [5,6,10,9]): pivô=9. O particionamento compara CADA elemento com 9 (logo comparamos 6 vs 9). Portanto, nesta execução específica, a comparação 6×9 ocorre.

Visão de caso médio clássico: em quicksort com entrada aleatória (ou com pivô aleatório), duas chaves x<y são comparadas SE e SOMENTE SE o primeiro pivô escolhido entre as chaves no intervalo [x..y] (presentes no vetor) é x ou y. A probabilidade é 2 / m, onde m é o número de chaves distintas do vetor que caem entre x e y (inclusive). Aqui, entre 6 e 9 no conjunto {1,2,3,5,6,9,10} só existem {6,9} (m=2). Logo probabilidade = 2/2 = 1.

Resposta: alternativa (e) 1.